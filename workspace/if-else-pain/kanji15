#!/usr/bin/env python3
import sys
import subprocess
import re

if len(sys.argv) < 2:
    print("Usage: compiler <input.py> [-o <output>]")
    sys.exit(1)

input_file = sys.argv[1]
output_file = "a.out"
if "-o" in sys.argv:
    idx = sys.argv.index("-o")
    if idx + 1 < len(sys.argv):
        output_file = sys.argv[idx + 1]
    else:
        print("❌ Output file not specified after -o")
        sys.exit(1)

with open(input_file) as f:
    lines = [line.rstrip('\n') for line in f]

data_section = []
text_section = [
    "    .text",
    "    .global _start",
    "_start:"
]

variables = {}
functions = {}
data_count = 0
label_counter = 0

def new_label(prefix="label"):
    global label_counter
    label = f"{prefix}{label_counter}"
    label_counter += 1
    return label

def add_data(val, add_newline=True):
    global data_count, data_section
    label = f"str{data_count}"
    real_str = val.encode('utf-8').decode('unicode_escape')
    if add_newline:
        real_str += "\n"
    bytes_list = [str(b) for b in real_str.encode('utf-8')]
    data_section.append(f"{label}:")
    for i in range(0, len(bytes_list), 10):
        chunk = bytes_list[i:i+10]
        data_section.append("    .byte " + ", ".join(chunk))
    data_section.append(f"{label}_len = . - {label}")
    data_count += 1
    return label

def emit_print(label):
    return [
        "    mov x0, #1",
        f"    adr x1, {label}",
        f"    mov x2, {label}_len",
        "    mov x8, #64",
        "    svc #0"
    ]

def eval_expr(expr, vars_dict):
    expr = expr.strip()
    m = re.fullmatch(r'chr\s*\(\s*(.+)\s*\)', expr)
    if m:
        val = eval_expr(m.group(1), vars_dict)
        try:
            return chr(int(val))
        except:
            return None
    m = re.fullmatch(r'ord\s*\(\s*(.+)\s*\)', expr)
    if m:
        inner = m.group(1)
        if (inner.startswith('"') and inner.endswith('"')) or (inner.startswith("'") and inner.endswith("'")):
            ch = inner[1:-1]
            if len(ch) == 1:
                return ord(ch)
            return None
        val = eval_expr(inner, vars_dict)
        if isinstance(val, str) and len(val) == 1:
            return ord(val)
        return None
    def repl_var(m):
        v = m.group(0)
        if v in vars_dict:
            val = vars_dict[v]
            return f'"{val}"' if isinstance(val, str) else str(val)
        return v
    expr_vars_re = re.compile(r'\b[a-zA-Z_][a-zA-Z0-9_]*\b')
    eval_str = expr_vars_re.sub(repl_var, expr)
    try:
        return eval(eval_str, {"__builtins__": {}})
    except:
        return None

def is_indented(line):
    return line.startswith("    ") or line.startswith("\t")

def remove_indent(line):
    if line.startswith("    "):
        return line[4:]
    if line.startswith("\t"):
        return line[1:]
    return line

def compile_conditional_block(lines, i, local_vars):
    branches = []
    def parse_cond(line):
        line = line.strip()
        if line.startswith("if "):
            return line[3:-1].strip()
        if line.startswith("elif "):
            return line[5:-1].strip()
        return None
    cond = parse_cond(lines[i])
    i += 1
    block = []
    while i < len(lines) and is_indented(lines[i]):
        block.append(remove_indent(lines[i]))
        i += 1
    branches.append((cond, block))
    while i < len(lines):
        ln = lines[i].strip()
        if ln.startswith("elif ") and ln.endswith(":"):
            cond = parse_cond(ln)
            i += 1
            blk = []
            while i < len(lines) and is_indented(lines[i]):
                blk.append(remove_indent(lines[i]))
                i += 1
            branches.append((cond, blk))
        elif ln == "else:":
            i += 1
            blk = []
            while i < len(lines) and is_indented(lines[i]):
                blk.append(remove_indent(lines[i]))
                i += 1
            branches.append((None, blk))
            break
        else:
            break
    for cond, blk in branches:
        if cond is None:
            compile_lines(blk, local_vars)
            break
        val = eval_expr(cond, local_vars)
        if val:
            compile_lines(blk, local_vars)
            break
    return i

def compile_lines(lines_to_compile, local_vars):
    global text_section, variables
    i = 0
    while i < len(lines_to_compile):
        ln = lines_to_compile[i]
        s = ln.strip()
        if not s or s.startswith("#"):
            i += 1
            continue
        if s.startswith("if ") and s.endswith(":"):
            i = compile_conditional_block(lines_to_compile, i, local_vars)
            continue
        if ("=" in s and not s.startswith("print") and not s.startswith("def") and not s.endswith("()") and not s.startswith("if ") and not s.startswith("elif ") and not s.startswith("else:")):
            name, expr = [t.strip() for t in s.split("=", 1)]
            if (expr.startswith('"') and expr.endswith('"')) or (expr.startswith("'") and expr.endswith("'")):
                val = expr[1:-1]
            else:
                val = eval_expr(expr, local_vars)
            if val is None:
                print(f"❌ Unknown var '{name}': {expr}")
                sys.exit(1)
            local_vars[name] = val
            i += 1
            continue
        if s.startswith("print(") and s.endswith(")"):
            args = [a.strip() for a in s[6:-1].split(",")]
            out = []
            for a in args:
                if (a.startswith('"') and a.endswith('"')) or (a.startswith("'") and a.endswith("'")):
                    v = a[1:-1]
                else:
                    v = eval_expr(a, local_vars)
                    if v is None:
                        print(f"❌ Unknown expr {a}")
                        sys.exit(1)
                out.append(str(v))
            lbl = add_data(" ".join(out), True)
            text_section += emit_print(lbl)
            i += 1
            continue
        if re.match(r'^[A-Za-z_][A-Za-z0-9_]*\(\)$', s):
            fn = s[:-2]
            if fn not in functions:
                print(f"❌ No func {fn}")
                sys.exit(1)
            compile_lines(functions[fn], {**variables, **local_vars})
            i += 1
            continue
        print(f"❌ Unsupported: {ln}")
        sys.exit(1)

i = 0
while i < len(lines):
    line = lines[i]
    if line.strip().startswith("def ") and line.strip().endswith("():"):
        fn = line.strip()[4:-3].strip()
        i += 1
        body = []
        while i < len(lines) and is_indented(lines[i]):
            body.append(remove_indent(lines[i]))
            i += 1
        functions[fn] = body
    else:
        compile_lines([line], variables)
        i += 1

text_section += [
    "    mov x0, #0",
    "    mov x8, #93",
    "    svc #0"
]

asm = [".data"] + data_section + [""] + text_section
with open("out.s", "w") as f:
    f.write("\n".join(asm) + "\n")

subprocess.run(["as", "-o", "out.o", "out.s"], check=True)
subprocess.run(["ld", "-o", output_file, "out.o"], check=True)

print(f"✅ Compiled to {output_file}")
